# Java基础-3

## 38.说一说hashCode()和equals()的关系

​       hashCode()用于获取哈希码(散列码),equals()用于比较两个对象是否相等
​       如果两个对象相等,则它们必须有相同的哈希码
​       如果两个对象有相同的哈希码,则它们未必相等

扩展:
​HashSet的实现原理:
​        HashSet首先会调用对象的hashCode()方法获取其哈希码,并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象,则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复,此时不会保存新加的对象。若不等说明对象不重复,但是它们存储的位置发生了碰撞,此时HashSet会采用链式结构在同一位置保存多个对象,即将新加对象链接到原来对象的之后。之后,再有新添加对象也映射到这个位置时,就需要与这个位置中所有的对象进行equals()比较,若均不相等,则将其链到最后一个对象之后。



## 39.为什么要重写hashCode()和equals()?

​        Object类提供的equals()方法默认是用 == 来进行比较的,也就是说只有两个对象是同一个对象时,才能返回相等的结果。而实际的业务中,我们通常的需求是,若两个不同的对象它们的内容是相同的,就认为它们相等。鉴于这种情况,Object类中equals()方法的默认实现是没有实用价值的,所以通常都要重写。
​        hashCode()和equals()具有联动关系,所以equals()重写时,一般hashCode()也重写。



## 40.==和equals()有什么区别?

==:
​       基本数据类型:比较两个数值是否相等;
​       引用数据类型:比较两个对象的内存地址,即判断它们是不是同一个对象

equals():
​       没有重写时,Object默认以==来实现
​       重写后, 会按照对象的内容进行比较,若两个对象内容相同则认为对象相等,否则认为对象不等



## 41.String类有哪些方法?

​       char charAt(int index)：返回指定索引处的字符；
​       String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；
​       String[] split(String regex)：以指定的规则将此字符串分割成数组；
​       String trim()：删除字符串前导和后置的空格；
​       int indexOf(String str)：返回子串在此字符串首次出现的索引；
​       int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；
​       boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；
​       boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；
​       String toUpperCase()：将此字符串中所有的字符大写；
​       String toLowerCase()：将此字符串中所有的字符小写；
​       String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；
​       String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。 

  

## 42.String可以被继承吗?

String类由final修饰,所以不能被继承。
​扩展:

String类设计为不可变类,主要考虑以下4点:
​         1.字符串在Java系统中广泛使用,为防止使用时被篡改,保证String类的安全
​	     2.在多线程中,只有不变的对象和值是线程安全的,可以在多个线程中共享数据
​	     3.在散列集合中,存放元素都要根据对象的hashCode()方法来确定元素的位置。由于字符串hashCode属性不会变更,保证了唯一性,使得类似HashMap,HashSet等容器才能实现相应的缓存功能
​	     4.字符串不可变时,字符串常量池才有意义。字符串常量池的出现,可以减少创建相同字面量的字符串
​	

## 43.说一说String和StringBuffer有什么区别

String:
​       不可变类,一旦一个String对象被创建,包含在这个对象中的字符序列是不可变的,直至这个对象被销毁StringBuffer:
​       字符序列可变的字符,StringBuffer被创建后,通append(),insert(),reverse(),setCharAt(),setLength()方法来改变字符串序列的字符序列。生成最终想要的字符串后,调用toString()方法将其转换为一个String对象。



## 44.StringBuffer和StringBuilder有什么区别

​       都是可变的字符串序列,都有共同的父类AbstractingBuilder,两个类的构造方法和成员方法也基本相同。
​       StringBuffer是线程安全的,StringBuilder是非线程安全的,StringBuilder性能略高。
​       一般情况下,要创建一个内容可变的字符串,建议优先考虑StringBuilder类。



## 45.使用字符串时,new和“”推荐使用哪种方式?

使用直接量的方式
        ""方式:JVM会使用常量池直接管理这个字符串
        new方式:JVM先试用常量池来管理直接量,再调用String类的构造器来创建一个新的String对象,新创建的对象被保存在堆内存中。



## 46.说一说你对字符串拼接的理解

最常用的有4种,列举这4中方式各自适用的场景
​       1.+运算符:拼接的是字符串直接量,适合使用+运算符实现拼接
​       2.StringBuilder:拼接的字符串包含变量,不要求线程安全
​       3.StringBuffer:拼接的字符串包含变量,要求线程安全
​       4.String类的concat方法:对两个字符串进行拼接,且包含变量  
​扩展:
​+运算符进行拼接时:
​        拼接的是字符串直接量,在编译时编译器将其直接优化为一个完整的字符串,和直接写一个完整的字符串是一样的拼接的字符串包含变量,在编译时编译器采用StringBuilder对其进行优化,即自动创建StringBuilder实例并调用其append()方法,将这些字符串拼接在一起,效率也很高

StringBuilder/StringBuffer拼接字符串:
​        StringBuilder/StringBuffer都有字符串缓冲区,缓冲区的容量在创建对象时确定,默认是16。 拼接的字符串超过缓冲区容量时,触发扩容机制(缓冲区双倍)
​        缓冲区频繁扩容会降低拼接的性能。

String的concat方法:
​        拼接逻辑:先创建一个足以容纳待拼接的两个字符串的字节数组,然后先后将两个字符串拼到这个数组里,最后将此数组转换为字符串
​        拼接大量:concat效率低于StringBuilder,拼接两个:concat效率高于StringBuilder



##  47.两个字符串相加的底层是如何实现的?

​        拼接的是字符串直接量,在编译时编译器将其直接优化为一个完整的字符串,和直接写一个完整的字符串是一样的拼接的字符串包含变量,在编译时编译器采用StringBuilder对其进行优化,即自动创建StringBuilder实例并调用其append()方法,将这些字符串拼接在一起,效率也很高



## 48.String a = "abc";,说一下这个过程会创建什么,放在哪里?

​       使用常量池来直接管理字符串直接量。
​       JVM会先检查产量池中是否已经存在有"abc",若没有则将"abc"存入常量池,否则就复用常量池中已有的“abc",将其引用赋值给变量a



## 49.new String("abc")是去了哪里,仅仅是在堆里面吗?

​        JVM会先试用常量池来管理字符串直接量,再创建一个新的String对象,这个对象会被保存在堆内存中。并且,堆中对象的数据会指向常量池中的直接量。



## 50.接口和抽象类有什么区别?

​        接口体现的是一种规范,抽象类体现的是一种模板式设计。
​        接口里只能包含抽象方法、静态方法、默认方法和私有方法,不能为普通方法提供方法实现;抽象类则完全可以包含普通方法。
​        接口里只能定义静态常量,不能定义普通成员变量;抽象类里则既可以定义普通成员变量,也可以定义静态常量
​        接口里不包含构造器;抽象类里可以包含构造器,抽象类的构造器并不是用于创建对象,而是让其子类调用这些构造器来完成术语抽象类的初始化操作
​        接口里不能包含初始化块;但抽象类则完全可以包含初始化块
​        一个类最多只能有一个直接父类,包括抽象类,但一个类可以直接实现多个接口,通过事先多个接口可以弥补Java单继承的不足
扩展:
​        接口和抽象类都不能被实例化,位于继承树的顶端,用于被其他类实现和继承
​        接口和抽象类都可以包含抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法。



## 51.接口中可以有构造函数吗?

​        接口定义的是一种规范,接口里不能包含构造器和初始化块定义。
​        接口里可以包含成员变量(只能是静态常量)、方法(抽象实例方法、类方法、默认方法或私有方法)、内部类(包括内部接口、枚举)定义。



## 52.谈谈你对面向接口编程的理解

​        接口体现的是一种规范和实现分离的设计哲学
​        充分利用接口可以极好地降低程序各模块之间的耦合,从而提高系统的可扩展性和可维护性。
​        基于这种原则,很多软件架构设计理论都倡导"面向接口"编程,而不是面向实现类编程



## 53.遇到过异常吗,如何处理?

捕获异常
        业务代码包裹在try块内部,当业务代码中发生任何异常时,系统都会为此异常创建一个异常对象。
        创建异常对象之后,JVM会在try块之后寻找可以处理它的catch块,并将异常对象交给这个catch块处理。

处理异常
        在catch块中处理异常时,应该先记录日志,便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况,进行相应的处理。
回收资源
        如果业务代码打开了某个资源,则需要再这段业务代码执行完毕后关闭这项资源。
        并且,无论是否发生异常,都要尝试关闭这项资源,将关闭资源的代码写在finally块内,可以满足这种需求,即无论是否发生异常,finally块内的代码总会被执行。



## 54.说一说Java的异常机制

关于异常处理:
         在Java中,处理异常的语句由try、catch、finally三部分组成。其中,try块用于包裹业务代码,catch块用于捕获并处理某个类型的异常,finally块则用于回收资源。当业务代码发生异常时,系统会创建一个异常对象,然后由JVM寻找可以处理这个异常的catch块,并将异常对象交给这个catch块处理。若业务代码打开了某项资源,则可以在finally块中关闭这项资源,因为无论是否发生异常,finally块一定会执行   
关于抛出异常:
        当程序出现错误时,系统会自动抛出异常。除此以外,Java也允许程序主动抛出异常。当业务代码中,判断某项错误的条件成立时,可以使用throw关键字向外抛出异常。在这种情况下,如果当前方法不知道该如何处理这个异常,可以在方法签名上通过throws关键字声明抛出异常,则该异常将交给JVM处理。

关于异常跟踪栈:
        当程序出现错误时,系统会自动抛出异常。除此以外,Java也允许程序主动抛出异常。当业务代码中,判断某项错误的条件成立时,可以使用throw关键字向外抛出异常。在这种情况下,如果当前方法不知道该如何处理这个异常,可以在方法签名上通过throws关键字声明抛出异常,则该异常将交给JVM处理。



## 55.请介绍Java的异常接口

Throwable: 

​       异常的顶级父类,代表所有非正常情况
​Error: 
​       指与虚拟机相关的问题。这种错误不可能回复或不可嫩捕获,将导致应用程序中断。
​       在定义方法时,也无需再其throws子句中声明该方法可能抛出Error及其任何子类
​Exception:
​       分为Checked异常和Runtime异常
​       所有的RuntimeException类及其子类的实例被称为Runtime异常,其它则称为Checked异常
​       Java程序认为Chekced异常都是可以被处理(修复)的异常,所以Java程序必须显示处理Checked异常
如果没有处理Checked异常,该程序在编译时就会发生错误,无法通过编译。
​       Runtime异常则更加灵活,无须显式声明抛出,可以使用try..catch块来实现



## 56.finally是无条件执行的吗?

​        不管try块中是否出现异常,也不管哪个catch块被执行,甚至在try块或catch块中执行了return语句,finally块总会被执行。
​注意事项:
​        在try块或catch块中使用System.exit(1)来退出虚拟机,则finally块将逝去执行的机会。



## 57.在finally中return会发生什么?

​         通常情况下,不要在finally块中使用return、throw等导致方法终止的语句,一旦在finally块中使用了return、throw语句,将会导致try块、catch块中的return、throw语句失效。
​详细解析:
​        执行try块、catch块时遇到了return或throw语句,系统会去找异常处理流程中是否包含finally块。            如果没有finally块,程序立即执行return或throw语句,方法终止,如果有finally块,系统立即开始执行finally块。

​       只有当finally块执行完成后,系统才会再次跳回来执行try块、catch块里的return或throw语句。
​       如果finally块里也使用了return或throw等导致方法终止的雨具,finally块已经终止了方法,系统将不会跳回去执行try块、catch块里的任何代码。