# Java基础-4

## 58.说一说你对static关键字的理解

​        Java类里只能包含成员变量、方法、构造器、初始化块、内部类(包括接口、枚举)5种成员,而static可以修饰成员变量、方法、初始化块、内部类(包括接口、枚举),以static修饰的成员就是类成员。类成员属于整个类,不属于单个对象。
​        对static关键字而言,规则:类成员(包括成员变量、方法、初始化块、内部类和内部枚举)不能访问实例成员(包括成员变量、方法、初始化块、内部类和内部枚举)。
​        类成员是属于类的,类成员的作用域比实例成员的作用域更大,完全可能出现类成已经初始化完成,但实例成员还不曾初始化的情况,如果允许类成员访问实例成员将会引起大量错误。



## 59.static修饰的类能不能被继承

static修饰的类可以被继承
​扩展:
​        如果使用static来修饰一个内部类,则这个内部类就属于外部类本身,而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类,有的地方也称为静态内部类。
​        static关键字的作用是把类的成员变成类相关,而不是实例相关,即static修饰的成员属于整个类,而不属于单个对象

静态内部类需满足如下规则:
​       1.静态内部类可以包含静态成员,也可以包含非静态成员
​       2.静态内部类不能访问外部类的实例成员,只能访问它的静态成员
​       3.外部类的所有方法,初始化块都能访问其内部定义的静态内部类
​       4.在外部类的外部,也可以实例化静态内部类,语法如下:
​                            外部类.内部类 变量名 = new 外部类.内部类构造方法();
​	  

## 60.static和final有什么区别?

​      static关键字可以修饰成员变量、成员方法、初始化块、内部类,被static修饰的成员是类的成员,它属于类、不属于单个对象。	  

类变量:
​       它随类的信息存储在方法区,并不随对象存储在堆中,类变量可以通过类名来访问,也可以通过对象名来访问,但建议通过类名访问它
​类方法:
​        类方法属于类,可以通过类名访问,也可以通过对象名访问,建议通过类名访问它。
​静态块:
​        静态块属于类,它在类加载的时候被隐式调用一次,之后便不会被调用了。
​静态内部类:
​        静态内部类可以包含静态成员,也可以包含非静态成员。静态内部类不能访问外部类的实例成员,只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。

final关键字可以修饰类、方法、变量
​        final类:final关键字修饰的类不可以被继承
​        final方法:final关键字修饰的方法不可以被重写
​        final变量:final关键字修饰的变量,一旦获得了初始值,就不可以被修改。

​        被final修饰的任何形式的变量,一旦获得了初始值,就不可以被修改。

 

## 61.说一说你对泛型的理解

​        Java集合有个缺点:把一个对象丢进集合里,集合就会"忘记"这个对象的数据类型,当再次取出该对象时,该对象的编译类型就变成了Object类型。
​       允许程序在创建集合时指定集合元素的类型,Java的参数化类型被称为泛型。
​       程序更加简洁,集合自动记住所有集合元素的数据类型,从而无须对集合元素进行强制类型转换。

 

## 62.介绍一下泛型擦除

​        为了与老的Java代码保持一致,也允许在使用带泛型声明的类时不指定实际的类型。如果没有为这个泛型类指定实际的类型,此时被称作rawtype(原始类型),默认是声明该泛型形参时指定的第一个上限类型
​        当把一个具有泛型信息的对象赋给另一个泛型信息的变量时,所有在尖括号之间的类型信息都将会被扔掉。  
​扩展:
​        对泛型而言,可以直接把一个List对象赋给一个List<String>对象,编译器仅仅提示"未经检查的转换"上述规则叫做泛型转换。



## 63.List<? super T>和List<? extends T>有什么区别?

?是类型通配符,List<?>可以表示各种泛型List的父类,意思是元素类型未知的List
​      List<? super T>用于设定类型统配符的下限,此处?代表一个未知的类型,但它必须是T的父类型
​      List<? extends T>用于设定类型通配符的上限,此处?代表一个未知的类型,但它必须是T的子类型。
​扩展:
​      数组和泛型有所不同,假设Foo是Bar的一个子类型(子类或者子接口)。
​      那么Foo[]依然是Bar[]的子类型,但G<Foo>不是G<Bar>的子类型,Foo[]自动向上转型为Bar[]的方式称为型变
​       Java的数组支持型变,但Java集合并不支持型变。
​       Java泛型的设计原则是:只要代码在编译时没有出现警告,就不会遇到运行时ClassCastException异常。  



## 64.说一说你对Java反射机制的理解

​        有时，程序在运行时接收到外部传入的一个对象,该对象的编译时类型是Object,但程序又需要调用该
对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息,而解决这个问题有以
下两种做法：
​        第一种做法是假设在编译时和运行时都完全知道类型的具体信息,在这种情况下,可以先使用instanceof运算符进行判断,再利用强制类型转换将其转换成其运行时类型的变量即可。
​        第二种做法是编译时根本无法预知该对象和类可能属于哪些类,程序只依靠运行时信息来发现该对象和类的真实信息,这就必须使用反射。

通过反射机制,可以实现如下的操作:
​        程序运行时，可以通过反射获得任意一个类的Class对象,并通过这个对象查看这个类的信息 
​        程序运行时，可以通过反射创建任意一个类的实例,并访问该实例的成员 
​        程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。



## 65.Java反射在实际醒目中有哪些应用场景?

​       1.使用JDBC时,如果要创建数据库的连接,则需要先通过反射机制加载数据库的驱动程序 

​       2.多数框架都支持注解/XML配置,从配置中解析出来的类是字符串,需要利用反射机制实例化

​       3.面向切面编程(AOP)的实现方式,是在程序运行时创建目标对象的代理类,这必须由反射机制来实现



## 66.说一说Java的四种引用方式

​       四种引用方式:强引用、软引用、弱引用、虚引用

强引用:

​        最常见的引用,即程序创建一个对象,并把这个对象赋值给一个引用变量,程序通过该引用变量来操作实际的对象。当一个对象被一个或一个以上的引用变量所引用时,它处于可达状态,不可能被系统垃圾回收机制回收。

软引用:

​       当一个对象只有软引用时,它可能被垃圾回收机制回收。

​       对于只有软引用的对象而言,

​       当系统内存空间足够时,它不会被系统回收,程序也可使用该对象。

​       当系统内存空间不足时,系统可能回收它。

​       软引用通常用于对内存敏感的程序中。

弱引用:

​        弱引用和软引用很像,但弱引用的引用级别更低。

​        当系统垃圾回收机制运行时,不管系统内存是否足够,总会回收该对象所占用的内存。必须等到垃圾回收机制运行时才能被回收。

虚引用:

​        完全类似于没有引用。虚引用对对象本身没有太大影响,对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时,那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态,虚引用不能单独使用,虚引用必须和引用队列联合使用。

